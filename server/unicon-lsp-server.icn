# uniclass.dir
# uniclass.pag
# avoid odbc (database)
# interfaces with SQLite - if persistent data 

link options
link basename
link ximage
link strings
import UniDoc
import json



global openFiles					# File container for open files
global built_in_functions			# List containing all native function names
global action_words					# List containing the action words (subset of reserved words)
global declarative_expressions		# List containing the declarative expressions (subset of reserved words)
global syntax_reserved_words		# List containing the syntax reserved words (subset of reserved words)
global keywords						# List containing all keywords
global preprocessors				# List containing all preprocessors
global link_functions				# table() with key:value --> file_name:table() with key:value --> procedure:list where list contains the parameters for the function  


#################################################################################
#                              usage procedure                                  #
#################################################################################


procedure usage()

# Modify options according to IDE

	prog := basename(&progname)
	write("Usage: ", prog, "[options]\n")
	write(prog, " is an implementation of the language server protocol.")
	write("You are handling the socket parameters/options for your IDE incorrectly (different IDEs pass different variations of the socket parameter when calling our program).")
	write("\nOptions:")
	write("\t -h : show this help\n")
	exit(-1)

end


#################################################################################
#                             Connect to Server                                 #
#################################################################################


procedure main(args)

	opts := options(args, "--socket:")
	if *opts = 0 then usage()
	port := \opts["-socket"] | usage()
	port := opts["-socket"]



	if &features == "MacOs" then
		client := "localhost:" || port
	else
		client := ":" || port

	client := ":" || port
	sock := open(client, "n") | stop("open(",server,") ERROR: ", &errortext)
	if /sock then stop("timeout")



#################################################################################
#                                   Main Loop                                   #
#################################################################################
	
	build_global_variables()
	build_unidoc()
	
	repeat {


		body := get_request(sock)
		jsontable := jtou(body)
	

		request_method := jsontable["method"]
		request_params := jsontable["params"]
		request_id := jsontable["id"]
		write("-----------------------------------------")
		write(request_method)
		write("-----------------------------------------")


		case request_method of {
			"initialize": {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize
				result := initialize_handler(request_params)
				res := build_response(request_id, result)
				write(res)
				writes(sock, res)
			 }
			"textDocument/didOpen" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didOpen
				if \(uri := request_params["textDocument"]["uri"]) then {
					file := uri[8:0]
					if f := open(file) then {
						initial_file_contents := reads(f, -1)
						close(f)
					}
				}
				openFiles[\uri] := initial_file_contents
			}
			"textDocument/didClose" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didClose
				uri := request_params["textDocument"]["uri"]
				delete(openFiles, \uri)
			}
			"textDocument/didChange" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didChange
				uri := request_params["textDocument"]["uri"]
				file_contents := request_params["contentChanges"][1]["text"]
				openFiles[\uri] := file_contents
			}
			"textDocument/declaration" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_declaration
				write("Don't know what to do with: ", request_method)
			 }
			"textDocument/completion" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion
				uri := request_params["textDocument"]["uri"]
				file_contents := openFiles[uri]
				result := handle_completion(request_params, file_contents)
				res := build_response(request_id, result)
			#	write(res)
				writes(sock, res)
			}
			"$/cancelRequest" : {
				# TODO:
				# 	One thread for communication
				# 	Spin up thread(s) for processing requests and tie request_id to thread
				# Handling cancel requests:
				#	kill thread associated with request_id
			
			
				write("We received a cancel request.")
			}
			default: { write("Don't know what to do with: ", request_method) }
		}
	}
end


#################################################################################
#                            Build Global Variables                             #
#################################################################################

procedure build_global_variables()
	openFiles := table()
	built_in_functions := [:function():]
	action_words := ["break", "case", "create", "critical", "every", "fail", "if", "initial", "initially", "next", "not", "repeat", "return", "suspend", "thread", "to", "until", "while"]
	declarative_expressions := ["abstract", "class", "global", "import", "invocable", "link", "local", "method", "package", "procedure", "record", "static"]
	syntax_reserved_words := ["all", "by", "default", "do", "end", "else", "of", "then"]
	keywords := ["&allocated", "&ascii", "&clock", "&col", "&collections", "&column", "&control", "&cset", "&current", "&date", "&dateline", "&digits", "&dump", "&e", "&errno", "&error", "&errornumber", "&errortext", "&errorvalue", "&errout", "&eventcode", "&eventsource", "&eventvalue", "&fail", "&features", "&file", "&host", "&input", "&interval", "&lcase", "&ldrag", "&letters", "&level", "&line", "&lpress", "&lrelease", "&main", "&mdrag", "&meta", "&mpress", "&mreleasee", "&now", "&null", "&output", "&phi", "&pi", "&pick", "&pos", "&progname", "&random", "&rdrag", "&regions", "&resize", "&row", "&rpress", "&rrelease", "&shift", "&source", "&storage", "&subject", "&time", "&trace", "&ucase", "&version", "&window", "&x", "&y"]
	preprocessors := ["$define", "$else", "$endif", "$error", "$ifdef", "$ifndef", "$include", "$line", "$undef", "#line"]

	
	link_functions := table()
	ipl := open("/home/mark/Documents/unicon/ipl/procs/*.icn")
	
# TODO: Setup our database of procedures contained within files, files within packages, etc. using UniDoc 
# All of this code below to be replaced.

	every ipl_file_line := !ipl do {

		reversed_file := reverse(ipl_file_line)                        # scan from end
		reversed_file ? {
			move(4)                                                    # skipping .icn
			file_name_without_ext := tab(upto("/"))
			file_name_without_ext := reverse(file_name_without_ext)
		}

		link_functions[file_name_without_ext] := table()


		current_file := open(ipl_file_line)
		every current_file_line := !current_file do {
			current_file_line ? {
				tab(many(' \t'))
				first_word := tab(many(&letters)) | &null
				if /first_word | first_word ~== "procedure" then next
				else {
					tab(many(' \t'))
					function_name := tab(upto("("))
					while function_name[-1] == " " do function_name := function_name[1:-1]
					link_functions[file_name_without_ext][function_name] := []
					parameter_list := []
					

#	Can have spaces, newlines in param list - see if we can extract methods/functions using UniDoc
#	
#					function_parameters := tab(upto(")")
#					function_parameters ? {
#						tab(many(' \t'))
#						while parameter := tab(upto(",")) do {
#							while parameter[-1] == " " do function_name := function_name[1:-1]
#							put(parameter_list, parameter)
#							move(1)
#						}
#						put(parameter_list, parameter)
#					} 
#					link_functions[file_name_without_ext][function_name] := parameter_list


				} 
			}
		}
	}
	write(ximage(link_functions))

end

#################################################################################
#                                 Unidoc                                        #
#################################################################################
# export IPATH=/home/mark/Documents/unicon/uni/unidoc
procedure build_unidoc()

	T := table()
	idoc := UniAll()

	idoc.setSourcePath("/home/mark/Documents/unicon/uni/3d")
	idoc.processFile("/home/mark/Documents/unicon/uni/3d")

   every pack := !idoc.packages do {
      write("package:", image(pack.getName()))

      write("  classes:")
      every x := pack.getClasses().get() do {
         write("\t", image(x.getName()))
         write("\t\tmethods:")
         every meth := x.getMethods().get() do {
            write("\t\t\t", image(meth.name))
            #writes("  params: ")
            #every writes(meth.getParams().get())
            #write("")
            }
         }

      write("  imports:")
      every x := pack.getImports().get() do {
         write("\t", image(x.getName()))
         }


      write("  files:")
      every x := pack.getFiles().get() do {
  
         write("\t", image(x.getName()))

         T[x.getName()] :=  x



         write("\t  procedures:")
         every y := x.getProcedures().get() do {
            write("\t\t", image(y.getName()))
            }
         
         write("\t  globals:")
         every y := x.getGlobals().get() do {
            write("\t\t", image(y.getName()))
            }


         }
      }


end

#################################################################################
#                               Get Request                                     #
#################################################################################


procedure get_request(sock)

	local body, msg

	while /body | body == "" do {
		
		# Block and get message on socket
		select(sock)
		msg := ready(sock)

		# Handling socket reading anomoly: header alone or header + body
		msg ? {
			tab(find("Content-Length:") + 15)
			len := integer(tab(many(&digits)))
			tab(upto("\r\n\r\n") + 4)
			if pos(0) then {
					body := ready(sock, len)
			}
			else
			 	body := tab(0)
		}
	}

	return body
end


#################################################################################
#                               Build Response                                  #
#################################################################################

procedure build_response(id, results)
	responseBody := "{\"jsonrpc\":\"2.0\",\"id\":"||id||",\"result\":"||results||"}"
	responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"
	return responseHeader || responseBody
end

#################################################################################
#                                Get Context                                    #
#################################################################################

# Return number for context reference
# Case 0: No context (empty file) - return all
# Case 1: Outside of procedure/class/(everything/whatever)
# Case 2: Inside a class
# Case 3: Inside a procedure (with / without end)
# Case 4: Access modifier (dot operator) for accessing object/class methods/data fields 
# Case 5: Variable assignments (last non blank character prior to position is "=")

#	variable:=(could be here)
#	variable := (could be here)
#	variable :=   (could be here)

procedure get_context(file_contents, line_number, character)

	if \file_contents | file_contents == "" then return 0
#	if (line_number == 0)
	
end

#################################################################################
#                             Response: initialize                              #
#################################################################################

# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize 
#
#
# TODO: 
# 	As you add more functionality (capabilities), you must add them to the string 
# 	  below within capabilities property
#	Handle results --> generator prepending escape sequence before special characters

procedure initialize_handler(jsontable)

	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true}}}"
	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true},\"textDocumentSync\":1,\"signatureHelp\":{\"contextSupport\":true}}}"

	return body
end


#################################################################################
#                         Capability: declarationProvider                       #
#################################################################################

# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_declaration
# 
#
# This capability defines "go to declaration" functionality.
# The go to declaration request is sent from the client to the server to resolve 
# the declaration location of a symbol at a given text document position.
# 
# Client Capability (VS code definition):
#	name: 
#	type: 
# Server Capability:
#	name: 
#	type: 
#




#################################################################################
#                         Capability: completionProvider                        #
#################################################################################


#############################################################
#                       Example Request                     #
#############################################################
#   {                                                       #
#       "jsonrpc": "2.0",                                   #
#       "id": 1,                                            #
#       "method": "textDocument/completion",                #
#       "params": {                                         #
#           "textDocument": {                               #
#           "uri": "file:///home/mark/Desktop/test.icn"     #
#           },                                              #
#           "position": {                                   #
#           "line": 0,                                      #
#           "character": 1                                  #
#           },                                              #
#           "context": {                                    #
#           "triggerKind": 1                                #
#            }                                              #
#        }                                                  #
#   }                                                       #
#############################################################



# Build list of keywords, reserved words, functions (done)
# Default: send keywords, reserved words
#  ||| concatenate lists


procedure handle_completion(params, file_contents)
	line_number := params["position"]["line"]
	character := params["position"]["character"]




	lines := fieldlist(file_contents, '\n')
	links := []
	every line := !lines do {
		line ? {
			tab(many(' \t'))

			if = "link" then {
				tab(many(' \t'))
				put(links, tab(many(&ascii)))
			}
		}
	}
	write(ximage(links))

	if \(line := lines[line_number + 1]) then {
		line ? {
			prefix := reverse(tab(character + 1))
			write("prefix: ", prefix)
			prefix ? { 
				word := tab(many(&letters ++ &digits ++ '_' ++ '&'))
			}
			if \word then {
				word := reverse(word)
			}
		}
	}
	
	write(word)


	T := table()
	T["isComplete"] :=  "__true__"
	L := []
	T["items"] := L

	completions := built_in_functions #["procedure", "main"]
	every w := !completions do 
		put(L, table("label", w)) 

	results := tojson(T)
	

#	results := "{\"isComplete\":\"true\",\"items\":[{\"label\":\"apple\"},{\"label\":\"along\"},{\"label\":\"anomoly\"},{\"label\":\"according\"},{\"label\":\"args\"}]}"
#	write(results)

	return results
end




