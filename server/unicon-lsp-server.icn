link options
link basename
link ximage
link strings
import UniDoc
import json
import ulsp

global openFiles                    # File container for open files
global built_in_functions           # List containing all native function names
global action_words                 # List containing the action words (subset of reserved words)
global declarative_expressions      # List containing the declarative expressions (subset of reserved words)
global syntax_reserved_words        # List containing the syntax reserved words (subset of reserved words)
global keywords                     # List containing all keywords
global preprocessors                # List containing all preprocessors
global T_packages                   # table containing database of packages (i.e. main, graphics3d, etc.) and their files.


#################################################################################
#                              usage procedure                                  #
#################################################################################


procedure usage()

# Modify options according to IDE

	prog := basename(&progname)
	write("Usage: ", prog, "[options]\n")
	write(prog, " is an implementation of the language server protocol.")
	write("You are handling the socket parameters/options for your IDE incorrectly (different IDEs pass different variations of the socket parameter when calling our program).")
	write("\nOptions:")
	write("\t -h : show this help\n")
	exit(-1)

end


#################################################################################
#                             Connect to Server                                 #
#################################################################################


procedure main(args)

	opts := options(args, "--socket:")
	if *opts = 0 then usage()
	port := \opts["-socket"] | usage()
	port := opts["-socket"]



	if &features == "MacOs" then
		client := "localhost:" || port
	else
		client := ":" || port

	client := ":" || port
	sock := open(client, "n") | stop("open(",server,") ERROR: ", &errortext)
	if /sock then stop("timeout")



#################################################################################
#                                   Main Loop                                   #
#################################################################################

	build_global_variables()

	repeat {


		body := get_request(sock)
		jsontable := jtou(body)


		request_method := jsontable["method"]
		request_params := jsontable["params"]
		request_id := jsontable["id"]
		write("-----------------------------------------")
		write(request_method)
		write("-----------------------------------------")


		case request_method of {
			"initialize": {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize
				result := initialize_handler(request_params)
				res := build_response(request_id, result)
				write(res)
				writes(sock, res)
			 }
			"textDocument/didOpen" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didOpen
				if \(uri := request_params["textDocument"]["uri"]) then {
					file := uri[8:0]
					if f := open(file) then {
						initial_file_contents := reads(f, -1)
						close(f)
					}
				}
				openFiles[\uri] := Workspace(uri[8:0], T_packages)
				workspace_object := openFiles[\uri]
				workspace_object.updateTempFile(initial_file_contents)
			}
			"textDocument/didClose" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didClose
				uri := request_params["textDocument"]["uri"]

				delete(openFiles, \uri)
			}
			"textDocument/didChange" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didChange
				uri := request_params["textDocument"]["uri"]
				file_contents := request_params["contentChanges"][1]["text"]
				workspace_object := openFiles[\uri]
				workspace_object.updateTempFile(file_contents)
			}
			"textDocument/declaration" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_declaration
				write("Don't know what to do with: ", request_method)
			 }
			"textDocument/completion" : {
				# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_completion
				uri := request_params["textDocument"]["uri"]
				workspace_object := openFiles[\uri]
				result := handle_completion(request_params, workspace_object)
				res := build_response(request_id, result)
				writes(sock, res)
			}
			"$/cancelRequest" : {
				# TODO:
				# 	One thread for communication
				# 	Spin up thread(s) for processing requests and tie request_id to thread
				# Handling cancel requests:
				#	kill thread associated with request_id


				write("We received a cancel request.")
			}
			default: { write("Don't know what to do with: ", request_method) }
		}
	}
end


#################################################################################
#                            Build Global Variables                             #
#################################################################################

procedure build_global_variables()

	openFiles := table()
	built_in_functions := [:function():]
	T_packages := build_lsp_database()
	action_words := ["break", "case", "create", "critical", "every", "fail", "if", "initial", "initially", "next", "not", "repeat", "return", "suspend", "thread", "to", "until", "while"]
	declarative_expressions := ["abstract", "class", "global", "import", "invocable", "link", "local", "method", "package", "procedure", "record", "static"]
	syntax_reserved_words := ["all", "by", "default", "do", "end", "else", "of", "then"]
	keywords := ["&allocated", "&ascii", "&clock", "&col", "&collections", "&column", "&control", "&cset", "&current", "&date", "&dateline", "&digits", "&dump", "&e", "&errno", "&error", "&errornumber", "&errortext", "&errorvalue", "&errout", "&eventcode", "&eventsource", "&eventvalue", "&fail", "&features", "&file", "&host", "&input", "&interval", "&lcase", "&ldrag", "&letters", "&level", "&line", "&lpress", "&lrelease", "&main", "&mdrag", "&meta", "&mpress", "&mreleasee", "&now", "&null", "&output", "&phi", "&pi", "&pick", "&pos", "&progname", "&random", "&rdrag", "&regions", "&resize", "&row", "&rpress", "&rrelease", "&shift", "&source", "&storage", "&subject", "&time", "&trace", "&ucase", "&version", "&window", "&x", "&y"]
	preprocessors := ["$define", "$else", "$endif", "$error", "$ifdef", "$ifndef", "$include", "$line", "$undef", "#line"]

end

#################################################################################
#                                 "Database"                                    #
#################################################################################

procedure build_lsp_database()

	paths := []
	put(paths, "/home/mark/Documents/unicon/uni/3d")
	put(paths, "/home/mark/Documents/unicon/uni/gui")
	#put(paths, "/home/mark/Documents/unicon/uni/parser")
	put(paths, "/home/mark/Documents/unicon/uni/xml")
	put(paths, "/home/mark/Documents/unicon/uni/lib")
	put(paths, "/home/mark/Documents/unicon/ipl/procs")
    put(paths, "/home/mark/Documents/unicon/uni/unidoc")

	T_packages := table()
	every path := !paths do build(path, T_packages)


end

procedure build(path, T_packages)

	local idoc

	idoc := UniAll()

	idoc.setSourcePath(path)
	idoc.processFile(path)

	x := idoc.packages

	every pack := !x do {
		
		if /T_packages[pack.getName()] then {
			T_packages[pack.getName()] := table()
			T_packages[pack.getName()]["files"] := table()
		}

		every file_in_pack := pack.getFiles().get() do {

			file_without_ext := &null
			file_in_pack.getName() ? {
				file_without_ext := tab(upto("."))
			}
			
			T_packages[pack.getName()]["files"][file_without_ext] := table()


			if /T_packages[pack.getName()]["files"][file_without_ext]["imports"] then T_packages[pack.getName()]["files"][file_without_ext]["imports"] := [] 
			every import_in_file := file_in_pack.getImports().get() do {
				put(T_packages[pack.getName()]["files"][file_without_ext]["imports"], import_in_file.getName())
			}


			if /T_packages[pack.getName()]["files"][file_without_ext]["procedures"] then T_packages[pack.getName()]["files"][file_without_ext]["procedures"] := []
			every procedure_in_file := file_in_pack.getProcedures().get() do {
				put(T_packages[pack.getName()]["files"][file_without_ext]["procedures"], procedure_in_file.getName())
			}

			if /T_packages[pack.getName()]["files"][file_without_ext]["classes"] then T_packages[pack.getName()]["files"][file_without_ext]["classes"] := table()
			every class_in_file := file_in_pack.getClasses().get() do {
				T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()] := table()
				T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["methods"] := []
				T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["attributes"] := []
				T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["comments"] := []
				T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["superclass"] := []


				every method_in_class := class_in_file.getMethods().get() do {
					put(T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["methods"], method_in_class.getName())
				}
				every class_param := class_in_file.getParams().get() do {
					put(T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["attributes"], class_param.getName())
				}
				every class_comment := class_in_file.getComments().get() do {
					put(T_packages[pack.getName()]["files"][file_without_ext]["classes"][class_in_file.getName()]["comments"], class_comment.get())
				}
			}
		}
	}
end

#################################################################################
#                               Get Request                                     #
#################################################################################


procedure get_request(sock)

	local body, msg

	while /body | body == "" do {

		# Block and get message on socket
		select(sock)
		msg := ready(sock)

		# Handling socket reading anomoly: header alone or header + body
		msg ? {
			tab(find("Content-Length:") + 15)
			len := integer(tab(many(&digits)))
			tab(upto("\r\n\r\n") + 4)
			if pos(0) then {
					body := ready(sock, len)
			}
			else
			 	body := tab(0)
		}
	}

	return body
end


#################################################################################
#                               Build Response                                  #
#################################################################################

procedure build_response(id, results)
	responseBody := "{\"jsonrpc\":\"2.0\",\"id\":"||id||",\"result\":"||results||"}"
	responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"
	return responseHeader || responseBody
end

#################################################################################
#                             Response: initialize                              #
#################################################################################

# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize
#
#
# TODO:
# 	As you add more functionality (capabilities), you must add them to the string
# 	  below within capabilities property
#	Handle results --> generator prepending escape sequence before special characters

procedure initialize_handler(jsontable)

	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true}}}"
	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true},\"textDocumentSync\":1,\"signatureHelp\":{\"contextSupport\":true}}}"

	return body
end

#################################################################################
#                         Capability: declarationProvider                       #
#################################################################################

# Detailed info available at: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_declaration


#################################################################################
#                         Capability: completionProvider                        #
#################################################################################

procedure getObjectName(line, character)
	identifiers := &letters ++ &digits ++ '_' ++ '-'

	line ? {
		temp := tab(character + 1)
		write("--------------------")
		write("temp")
		write(temp)
		write("--------------------")
		while c := move(-1) do {
			write("-----------------")
			write("c: ")
			write(c)
			write("-----------------")
			if (c ** identifiers) ~== c then { 
				break
			}
		}

		write("Before if ", &subject[&pos:0])
		if ="." then {
			write("Inside if ", &subject[&pos:0])
			move(-1)

			while c := move(-1) do {
				if (c ** identifiers) ~== c then { 
					move(1)
					break
				}
			}
			write("Inside if, after while ", &subject[&pos:0])
			objectName := tab(upto("."))
			write("--------------------")
			write("Object name: ")
			write(objectName)
			write("--------------------")
			return objectName
			
		}
	}

end

procedure getDesiredLine(line, file)
	f := open(file)
	every !line do read(f)
	desired_line := read(f)
	return desired_line
end

procedure getContext(line, character, file)

	desired_line := getDesiredLine(line, file)

	#-----------------------------------------------#
	#----------- Case "inside comment" -------------#
	#-----------------------------------------------#
	
	desired_line ? {
		while (&pos < character) do {
			ch := move(1)
			if ch == "#" then return "inside comment"
		}
	}

	#-----------------------------------------------#
	#-------- Case "after dot operator" ------------#
	#-----------------------------------------------#

	if objectName := getObjectName(desired_line, character) then 
		return "after dot operator"  

	#-----------------------------------------------#
	#---------------- Default case -----------------#
	#-----------------------------------------------#

	
end

procedure handle_completion(params, workspace)
	line := params["position"]["line"]
	character := params["position"]["character"]

	_context := getContext(line, character, workspace.temp_file)

	write("-------------------------")
	write("Context: ", _context)
	write("-------------------------")

	results_table := table()
	results_table["isComplete"] :=  "__true__"
	results_table["items"] := []

	case _context of {
		"inside comment" : {
			write("Hit inside comment case")
			results_table["items"] := []
		}
		"after dot operator" : {
			write("Hit after dot operator case")
			desired_line := getDesiredLine(line, workspace.temp_file)	
			objectName := getObjectName(desired_line, character) 
			workspace.buildObjectCompletionItems(results_table, objectName)
		}
		default : { 
			write("Hit default case")
			buildDefaultCompletionItems(results_table, workspace)
		}
	}

	results := tojson(results_table)
	return results


end


procedure addBuiltInFunctionsCompletionItems(results_table)

	every _function := !built_in_functions do {
		put(results_table["items"], table("label", _function, "kind", 3))
	}

end

procedure addActionWordsCompletionItems(results_table)

	every _actionWord := !action_words do {
		put(results_table["items"], table("label", _actionWord))
	}

end

procedure addDeclarativeExpressionsCompletionItems(results_table)

	every _declarativeExpression := !declarative_expressions do {
		put(results_table["items"], table("label", _declarativeExpression))
	}

end

procedure addSyntaxReservedWordsCompletionItems(results_table)

	every _syntaxReservedWord := !syntax_reserved_words do {
		put(results_table["items"], table("label", _syntaxReservedWord))
	}

end

procedure addKeywordsCompletionItems(results_table)

	every _keyword := !keywords do {
		put(results_table["items"], table("label", _keyword, "kind", 14))
	}

end

procedure addPreprocessorCompletionItems(results_table)

	every _preprocessor := !preprocessors do {
		put(results_table["items"], table("label", _preprocessor))
	}

end

procedure addWorkspaceProcedures(results_table, workspace)

	every _internalProcedure := !workspace.getInternalProcedures() do {
		put(results_table["items"], table("label", _internalProcedure, "kind", 3))
	}
	every _linkedProcedure := !workspace.getLinkedProcedures() do {
		put(results_table["items"], table("label", _linkedProcedure, "kind", 3))
	}
	every _importedProcedure := !workspace.getImportedProcedures() do {
		put(results_table["items"], table("label", _importedProcedure, "kind", 3))
	}

end

procedure addWordspaceClasses(results_table, workspace)
	
	every _internalClass := !workspace.getInternalClasses() do {
		put(results_table["items"], table("label", _internalClass, "kind", 3))
	}
	every _linkedClass := !workspace.getLinkedClasses() do {
		put(results_table["items"], table("label", _linkedClass, "kind", 3))
	}
	every _importedClass := !workspace.getImportedClasses() do {
		put(results_table["items"], table("label", _importedClass, "kind", 3))
	}

end

procedure buildDefaultCompletionItems(results_table, workspace)
	addActionWordsCompletionItems(results_table)
	addBuiltInFunctionsCompletionItems(results_table)
	addDeclarativeExpressionsCompletionItems(results_table)
	addKeywordsCompletionItems(results_table)
	addPreprocessorCompletionItems(results_table)
	addSyntaxReservedWordsCompletionItems(results_table)
	addWordspaceClasses(results_table, workspace)
	addWorkspaceProcedures(results_table, workspace)
end