link options
link basename
link json
link ximage

procedure usage()

# Modify options according to IDE

	prog := basename(&progname)
	write("Usage: ", prog, "[options]\n")
	write(prog, " is an implementation of the language server protocol.")
	write("You are handling the socket parameters/options for your IDE incorrectly (different IDEs pass different variations of the socket parameter when calling our program).")
	write("\nOptions:")
	write("\t -h : show this help\n")
	exit(-1)

end


#################################################################################
#							Connect to Server									#
#################################################################################


procedure main(args)

	opts := options(args, "--socket:")
	if *opts = 0 then usage()
	port := \opts["-socket"] | usage()
	port := opts["-socket"]

	client := ":" || port
	sock := open(client, "n") | stop("open(",server,") ERROR: ", &errortext)
	if /sock then stop("timeout")



#################################################################################
#									Main			 							#
#################################################################################
	

	repeat {

		body := get_request(sock)

		jsontable := jtou(body)
	

		request_method := jsontable["method"]
		request_params := jsontable["params"]
		request_id := jsontable["id"]
		write("-----------------------------------------")
		write(request_method)
		write("-----------------------------------------")

		case request_method of {
			"initialize": {
				result := initialize_handler(request_params)
				res := build_response(request_id, result)
				write(res)
				writes(sock, res)
				
			 }
			
# Array of strings holding the currently "opened" files (i.e. tabs in VS workspace) 
# didOpen -- add file name to the array
#	-Appears client is holding a list of open files.
#	-When file is not in the list of currently "open" files and we select the file, this file will be added to the list.
#	-If we then cycle through files that are already "open" (i.e. in the list), we will not receive another didOpen notification.
#	-In essence, we only recieve the didOpen notification the first time the file is opened. Cycling does not trigger further didOpen notifications.
#
# didClose
#	-Triggered by closing a tab in VS code. 
#	-This removes the file from the list of open files on the client side and send notification to server.
#	-Action on server --> remove file from the list of open files on server end, free up memory space held by that file (not sure if we are using string or creating a temp file).
#	
# didChange -- file synchronization
#	-Each "open" file requires some way to synchronize (create temp file or hold in string)
#	-Full file sync vs. 
#
# TODO:
#	after implementing open file storing on server side, adjust parameters for handler functions to accept file as well.

			"textDocument/didOpen" : {
				
			}
			"textDocument/didClose" : {

			}
			"textDocument/didChange" : {
				file_contents := request_params["contentChanges"]
				file_contents_1 := file_contents[1]
				
				#write(ximage(file_contents_1))
				file_text := String(file_contents_1["text"])
				write(file_text)
			}
			"textDocument/declaration" : {
				write("Don't know what to do with: ", request_method)
			 }
			"textDocument/completion" : {
				#result := handle_completion(request_params, file_text)
				#res := build_response(request_id, result)
				#write(res)
				#writes(sock, res)
				file_contents := &null
				file_text := &null

			}
			"$/cancelRequest" : {
				# TODO:
				# 	One thread for communication
				# 	Spin up thread(s) for processing requests and tie request_id to thread
				# Handling cancel requests:
				#	kill thread associated with request_id
			
			
				write("We received a cancel request.")
			}
			default: { write("Don't know what to do with: ", request_method) }
		}
	}
end

#################################################################################
#								Get Request										#
#################################################################################


procedure get_request(sock)

	local body, msg

	while /body | body == "" do {
		
		# Block and get message on socket
		select(sock)
		msg := ready(sock)

		# Handling socket reading anomoly: header alone or header + body
		msg ? {
			tab(find("Content-Length:") + 15)
			len := integer(tab(many(&digits)))
			tab(upto("\r\n\r\n") + 4)
			if pos(0) then {
					body := ready(sock, len)
			}
			else
			 	body := tab(0)
		}
	}

	return body
end



#################################################################################
#								Build Response									#
#################################################################################

procedure build_response(id, results)
	responseBody := "{\"jsonrpc\":\"2.0\",\"id\":"||id||",\"result\":"||results||"}"
	responseHeader := "Content-Length:" || *responseBody || "\r\n\r\n"
	return responseHeader || responseBody
end


#################################################################################
#							Response: initialize								#
#################################################################################

# TODO: 
# 	As you add more functionality (capabilities), you must add them to the string 
# 	below within capabilities property

#	Handle results --> generator prepending escape sequence before special characters

procedure initialize_handler(jsontable)

	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true}}}"
	body := "{\"capabilities\":{\"completionProvider\":{\"resolveProvider\":true},\"textDocumentSync\":1}}"

	return body
end


#################################################################################
#							Capability: declarationProvider						#
#################################################################################

# This capability defines "go to declaration" functionality.
# The go to declaration request is sent from the client to the server to resolve 
# the declaration location of a symbol at a given text document position.
# 
# Client Capability (VS code definition):
#	name: 
#	type: 
# Server Capability:
#	name: 
#	type: 
#




#################################################################################
#							Capability: completionProvider						#
#################################################################################


#############################################################
#						Example Request 				    #
#############################################################
#	{													    #
#  		"jsonrpc": "2.0",								    #
#  		"id": 1,										    #
#  		"method": "textDocument/completion",				#
#  		"params": {											#
#    		"textDocument": {								#
#      		"uri": "file:///home/mark/Desktop/test.icn"		#
#    		},												#
#    		"position": {									#
#      		"line": 0,										#
#      		"character": 1									#
#    		},												#
#    		"context": {									#
#      		"triggerKind": 1								#
#   		 }												#
# 		 }													#
#	}														#
#############################################################

procedure handle_completion(params, file_contents)
	textDocument := params["textDocument"]["uri"]
	line := params["position"]["line"]
	character := params["position"]["character"]

#	 Move back 1 character at a time until char == " " or start of line
#	 Counter variable to make sure we do not exceed value of character (position in line) 
#	 Issue with reading file - reading original file, not buffered.

	f := open("nothing_to_see_here.txt", "w") | stop(&errortext, "fail to open")
	write(f, file_contents)


	close(f)

	f := open("nothing_to_see_here.txt") | stop(&errortext, "fail to open")

	every !line & read(f)
	data := read(f)
	write(data)

	close(f)	
	
#	Random words in a \\n line test \\n


#	current_word := ""
#	data ? {
#		if character == 0
#		move(character)
#		while(ch ~== ' ') do {
#			ch := move(-1)
#			current_word := current_word || ch
#		}
#	}
#	current_word := reverse(current_word)



#	data ? {
#		move(character)

#		word := ""
#		count := character
#		ch := move(count)

#		special operators in scanning environment 
		
#		while (ch ~== ' ' & count > 0) do {
#			writes(ch)
#			write(count)
#			word := word || ch
#			count := count - 1
#			ch := move(count)
#		}
#		word := reverse(word)
#	}
#	
#	write(word)
	


#	procedure, link, class, main


	
#	data ? {
#
#		position := character - 1
#
#		while ((data[position] ~== " ") & (position > 0)) do position := position - 1 
#		
#		move(position)
#		char := tab(1)
#		#word := tab(many(&digits ++ &letters ++ '_'))
#	}
#
#	write(image(word))
	


#	 tojson
#	T := table()
#	T["isComplete"] :=  &null # "__true__"
#	L := []
#	T["items"] := L
#
#	completions := ["procedur", "main"]
#	every w := !completions do 
#		put(L, table("label", w)) 
#
#	write(ximage(T))
#	write(ximage(utoj(L))) 
#	results := utoj(T)
#	
#	write(ximage(results))


	results := "{\"isComplete\":\"true\",\"items\":[{\"label\":\"apple\"},{\"label\":\"along\"},{\"label\":\"anomoly\"},{\"label\":\"according\"},{\"label\":\"args\"}]}"
#	write(results)

	return results
end

